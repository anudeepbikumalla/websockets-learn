<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced WebSocket Patterns</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap"
    rel="stylesheet" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #ffffff;
      --card: #f8fafc;
      --card2: #f1f5f9;
      --border: #e2e8f0;
      --text: #0f172a;
      --muted: #64748b;
      --dim: #475569;
      --green: #16a34a;
      --blue: #0284c7;
      --purple: #7c3aed;
      --yellow: #ca8a04;
      --red: #dc2626;
      --orange: #ea580c;
    }
    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }

    /* ‚îÄ‚îÄ HERO ‚îÄ‚îÄ */
    .hero {
      text-align: center;
      padding: 64px 24px 48px;
      background: radial-gradient(ellipse 80% 60% at 50% 0%, rgba(124, 58, 237, .08), transparent);
      border-bottom: 1px solid var(--border);
    }
    .hero-tag {
      display: inline-block;
      background: rgba(124, 58, 237, .1);
      color: var(--purple);
      border: 1px solid rgba(124, 58, 237, .25);
      border-radius: 99px;
      padding: 4px 14px;
      font-size: .75rem;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 20px;
    }
    .hero h1 {
      font-size: clamp(2rem, 5vw, 3.5rem);
      font-weight: 800;
      letter-spacing: -1px;
      margin-bottom: 16px;
      color: var(--text);
    }
    .hero p {
      font-size: 1.1rem;
      color: var(--dim);
      max-width: 600px;
      margin: 0 auto;
    }
    .back-link {
      display: inline-block;
      margin-top: 24px;
      font-size: .9rem;
      font-weight: 600;
      color: var(--blue);
      text-decoration: none;
    }
    .back-link:hover { text-decoration: underline; }

    /* ‚îÄ‚îÄ PAGE LAYOUT ‚îÄ‚îÄ */
    .page {
      max-width: 900px;
      margin: 0 auto;
      padding: 48px 24px;
      display: flex;
      flex-direction: column;
      gap: 64px;
    }

    /* ‚îÄ‚îÄ PATTERN CARD ‚îÄ‚îÄ */
    .pattern-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
    }
    .pattern-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      background: var(--card2);
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .pattern-icon { font-size: 1.5rem; }
    .pattern-title {
      font-size: 1.25rem;
      font-weight: 800;
      color: var(--text);
    }

    .pattern-body {
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .story-section h3 {
      font-size: .75rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 800;
      color: var(--blue);
      margin-bottom: 8px;
    }
    .story-section p {
      font-size: .95rem;
      color: var(--dim);
      line-height: 1.7;
    }

    /* ‚îÄ‚îÄ CODE SNIPPET ‚îÄ‚îÄ */
    .code-block {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      font-family: 'Fira Code', monospace;
      font-size: .8rem;
      color: #334155;
      overflow-x: auto;
      line-height: 1.7;
    }
    .code-block .kw { color: #0284c7; } /* Keyword */
    .code-block .fn { color: #16a34a; } /* Function */
    .code-block .str { color: #dc2626; } /* String */
    .code-block .cm { color: #64748b; font-style: italic; } /* Comment */

    /* ‚îÄ‚îÄ SIMULATOR ‚îÄ‚îÄ */
    .simulator {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 20px;
      background: #ffffff;
    }
    .sim-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    .sim-title {
      font-size: .85rem;
      font-weight: 700;
      color: var(--purple);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .sim-actions {
      display: flex;
      gap: 8px;
    }
    .btn {
      padding: 8px 16px;
      border-radius: 6px;
      border: none;
      font-family: 'Inter', sans-serif;
      font-size: .8rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--card2);
      color: var(--text);
      border: 1px solid var(--border);
      transition: all .2s;
    }
    .btn:hover { background: var(--border); }
    .btn-primary { background: var(--blue); color: #fff; border: none; }
    .btn-primary:hover { background: #0369a1; }
    .btn-error { background: var(--red); color: #fff; border: none; }
    
    .sim-log {
      background: #0f172a;
      border-radius: 8px;
      height: 160px;
      overflow-y: auto;
      padding: 12px;
      font-family: 'Fira Code', monospace;
      font-size: .75rem;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .log-line {
      display: flex;
      gap: 10px;
      animation: slidein 0.2s ease;
    }
    @keyframes slidein {
      from { opacity: 0; transform: translateX(-5px); }
      to { opacity: 1; transform: translateX(0); }
    }
    .log-time { color: #64748b; flex-shrink: 0; }
    .log-msg { color: #e2e8f0; }
    .log-msg.tx { color: #38bdf8; }
    .log-msg.rx { color: #4ade80; }
    .log-msg.err { color: #f87171; }
    .log-msg.sys { color: #a78bfa; }

    @media (max-width: 768px) {
      .hero h1 { font-size: 2rem; }
      .page { padding: 24px 16px; }
      .pattern-body { padding: 16px; }
    }
  </style>
</head>

<body>

  <div class="hero">
    <div class="hero-tag">Architecture</div>
    <h1>Advanced Patterns</h1>
    <p>Professional-grade architectural patterns for structuring data flows in massive, production-ready WebSocket applications.</p>
    <a href="index.html" class="back-link">‚Üê Back to Learning Hub</a>
  </div>

  <div class="page">

    <!-- PATTERN 1: MESSAGE ROUTER -->
    <div class="pattern-card">
      <div class="pattern-header">
        <div class="pattern-icon">üö¶</div>
        <div class="pattern-title">The "Message Router" Pattern</div>
      </div>
      <div class="pattern-body">
        <div class="story-section">
          <h3>üìñ The Logic & Flow</h3>
          <p>
            Instead of stuffing a massive <code>switch/case</code> or hundreds of <code>if/else</code> statements inside a single <code>onmessage</code> listener, architects use a central "Router". <br><br>
            All incoming JSON is required to have a specific <code>type</code> field. The router intercepts the raw string, parses it, and maps the <code>type</code> to an isolated handler function. This maps exactly to how Express.js routes HTTP REST endpoints!
          </p>
        </div>

        <div class="story-section">
          <h3>üíª Implementation Code</h3>
          <div class="code-block">
<span class="cm">// 1. Define distinct, decoupled handler functions</span>
<span class="kw">const</span> handlers = {
  <span class="str">"CHAT_MSG"</span>: <span class="fn">(data) =></span> renderMessage(data.text),
  <span class="str">"USER_TYPING"</span>: <span class="fn">(data) =></span> showIndicator(data.user),
  <span class="str">"SYSTEM_ALERT"</span>: <span class="fn">(data) =></span> showAlert(data.msg)
};

<span class="cm">// 2. The central router is incredibly clean</span>
ws.<span class="fn">onmessage</span> = (event) => {
  <span class="kw">const</span> { type, data } = JSON.<span class="fn">parse</span>(event.data);
  
  <span class="cm">// 3. Route to the exact function if it exists</span>
  <span class="kw">if</span> (handlers[type]) {
    handlers[type](data);
  } <span class="kw">else</span> {
    console.warn(<span class="str">"Unknown event type:"</span>, type);
  }
};
          </div>
        </div>

        <div class="simulator">
          <div class="sim-header">
            <div class="sim-title">‚ñ∂Ô∏è Interactive Simulator</div>
            <div class="sim-actions">
              <button class="btn btn-primary" onclick="simRouter('CHAT')">Simulate Chat</button>
              <button class="btn" onclick="simRouter('TYPING')">Simulate Typing</button>
              <button class="btn btn-error" onclick="simRouter('UNKNOWN')">Unknown Event</button>
            </div>
          </div>
          <div class="sim-log" id="log-router"></div>
        </div>
      </div>
    </div>


    <!-- PATTERN 2: MIDDLEWARE / GUARD -->
    <div class="pattern-card">
      <div class="pattern-header">
        <div class="pattern-icon">üõ°Ô∏è</div>
        <div class="pattern-title">The "Middleware Guard" Pattern</div>
      </div>
      <div class="pattern-body">
        <div class="story-section">
          <h3>üìñ The Logic & Flow</h3>
          <p>
            When acting as the Server, you must protect your core logic. If every endpoint manually checks "Is this user admin?" or "Did they hit the rate limit?", you violate the DRY (Don't Repeat Yourself) principle.<br><br>
            A Middleware Guard intercepts the incoming WebSocket packet, executes security rules (Auth, Rate Limiting, Schema Validation), and calls <code>next()</code> only if it's safe. If it fails, the guard abruptly swallows the packet and returns an error without the core logic ever knowing it happened.
          </p>
        </div>

        <div class="story-section">
          <h3>üíª Implementation Code</h3>
          <div class="code-block">
<span class="cm">// A pipeline of guards that executes sequentially</span>
<span class="kw">const</span> middlewarePipeline = [
  <span class="fn">checkRateLimit</span>,
  <span class="fn">validateAuthToken</span>,
  <span class="fn">parseAndSanitizeJSON</span>
];

ws.<span class="fn">on</span>(<span class="str">'message'</span>, <span class="kw">async</span> (rawStr) => {
  <span class="kw">try</span> {
    <span class="cm">// Run through all guards</span>
    <span class="kw">for</span> (<span class="kw">const</span> guard <span class="kw">of</span> middlewarePipeline) {
      <span class="kw">await</span> <span class="fn">guard</span>(ws, rawStr); <span class="cm">// Throws Error if malicious!</span>
    }
    <span class="cm">// If we survived the guards, process the actual message safely!</span>
    <span class="fn">processCoreLogic</span>(rawStr);
    
  } <span class="kw">catch</span> (securityError) {
    ws.<span class="fn">send</span>(JSON.stringify({ error: securityError.message }));
  }
});
          </div>
        </div>

        <div class="simulator">
          <div class="sim-header">
            <div class="sim-title">‚ñ∂Ô∏è Interactive Simulator (Server Perspective)</div>
            <div class="sim-actions">
              <button class="btn btn-primary" onclick="simGuard('VALID')">Send Valid Req</button>
              <button class="btn btn-error" onclick="simGuard('SPAM')">Simulate Spam Attack</button>
            </div>
          </div>
          <div class="sim-log" id="log-guard"></div>
        </div>
      </div>
    </div>


    <!-- PATTERN 3: HEARTBEAT WATCHDOG -->
    <div class="pattern-card">
      <div class="pattern-header">
        <div class="pattern-icon">üíì</div>
        <div class="pattern-title">The "Heartbeat Watchdog" Pattern</div>
      </div>
      <div class="pattern-body">
        <div class="story-section">
          <h3>üìñ The Logic & Flow</h3>
          <p>
            TCP connections can "ghost" or die silently if a router resets, leaving the browser thinking it's connected while the server thinks it's dead. The <code>onclose</code> event often fails to fire.<br><br>
            To prevent this, the client implements a "Watchdog Timer". It expects a heartbeat ping from the server every 5 seconds. If the client misses 2 pings in a row (10 seconds of silence), the watchdog bites: it explicitly forces a socket closure and instantly triggers the reconnect logic.
          </p>
        </div>

        <div class="story-section">
          <h3>üíª Implementation Code</h3>
          <div class="code-block">
<span class="kw">let</span> watchdogTimeout;

<span class="kw">function</span> <span class="fn">resetWatchdog</span>() {
  clearTimeout(watchdogTimeout);
  <span class="cm">// If server is silent for 10s, we assume it's dead</span>
  watchdogTimeout = setTimeout(() => {
    console.warn(<span class="str">"Server missed heartbeat! Forcing reconnect."</span>);
    ws.<span class="fn">close</span>(); <span class="cm">// Forces the onclose event to fire and auto-reconnect</span>
  }, 10000);
}

ws.<span class="fn">addEventListener</span>(<span class="str">'open'</span>, resetWatchdog);

ws.<span class="fn">addEventListener</span>(<span class="str">'message'</span>, (event) => {
  <span class="cm">// We received data (either a ping or real logic). The server is alive!</span>
  <span class="fn">resetWatchdog</span>();
});
          </div>
        </div>

        <div class="simulator">
          <div class="sim-header">
            <div class="sim-title">‚ñ∂Ô∏è Interactive Simulator</div>
            <div class="sim-actions">
              <button class="btn btn-primary" onclick="simWatchdog('START')">Start Server Pings</button>
              <button class="btn btn-error" onclick="simWatchdog('KILL')">Sever Cable (Ghost)</button>
            </div>
          </div>
          <div class="sim-log" id="log-watchdog"></div>
        </div>
      </div>
    </div>


    <!-- PATTERN 4: REQ/RES CORRELATION -->
    <div class="pattern-card">
      <div class="pattern-header">
        <div class="pattern-icon">üîó</div>
        <div class="pattern-title">The "Request-Response Correlation" Pattern</div>
      </div>
      <div class="pattern-body">
        <div class="story-section">
          <h3>üìñ The Logic & Flow</h3>
          <p>
            WebSockets are "fire and forget". When you send an HTTP GET request, the response is attached directly to it. In WebSockets, if you send 3 questions, the server might send 3 answers purely out of order.<br><br>
            To bridge this gap, we attach a unique <code>requestId</code> (Correlation ID) to the JSON payload. We wrap the <code>ws.send()</code> in a Promise, and store the Promise's <code>resolve</code> function inside a global Map, keyed by the ID. When the server echoes the ID back later, we find the function in the Map, execute it, and seamlessly fulfil the awaiting Promise.
          </p>
        </div>

        <div class="story-section">
          <h3>üíª Implementation Code</h3>
          <div class="code-block">
<span class="cm">// Map to cleanly store callbacks waiting for a specific server reply</span>
<span class="kw">const</span> pendingAwaits = <span class="kw">new</span> <span class="fn">Map</span>();

ws.<span class="fn">onmessage</span> = (event) => {
  <span class="kw">const</span> packet = JSON.<span class="fn">parse</span>(event.data);
  <span class="kw">if</span> (pendingAwaits.<span class="fn">has</span>(packet.reqId)) {
    <span class="kw">const</span> resolveFn = pendingAwaits.<span class="fn">get</span>(packet.reqId);
    <span class="fn">resolveFn</span>(packet.data);
    pendingAwaits.<span class="fn">delete</span>(packet.reqId); <span class="cm">// Cleanup</span>
  }
};

<span class="kw">async function</span> <span class="fn">fetchUser</span>(userId) {
  <span class="kw">return new</span> <span class="fn">Promise</span>((resolve) => {
    <span class="kw">const</span> reqId = Math.<span class="fn">random</span>().toString(36);
    pendingAwaits.<span class="fn">set</span>(reqId, resolve); <span class="cm">// Store the 'resolve' bucket</span>
    
    ws.<span class="fn">send</span>(JSON.stringify({ reqId, type: <span class="str">"GET_USER"</span>, userId }));
  });
}

<span class="cm">// Usage is totally linear!</span>
<span class="kw">const</span> userProfile = <span class="kw">await</span> <span class="fn">fetchUser</span>(99); 
          </div>
        </div>

        <div class="simulator">
          <div class="sim-header">
            <div class="sim-title">‚ñ∂Ô∏è Interactive Simulator</div>
            <div class="sim-actions">
              <button class="btn btn-primary" onclick="simReqRes('DB_FAST')">Query Fast DB</button>
              <button class="btn" onclick="simReqRes('DB_SLOW')">Query Slow DB</button>
            </div>
          </div>
          <div class="sim-log" id="log-reqres"></div>
        </div>
      </div>
    </div>

  </div> <!-- end page -->

  <script>
    // --- Helper for logs ---
    function logTo(boxId, msg, type) {
      const box = document.getElementById(boxId);
      const time = new Date().toLocaleTimeString('en-US', {hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit'});
      const el = document.createElement('div');
      el.className = 'log-line';
      el.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-msg ${type}">${msg}</span>`;
      box.appendChild(el);
      box.scrollTop = box.scrollHeight;
    }

    // --- 1. Router Simulator ---
    function simRouter(action) {
      if(action === 'CHAT') {
        logTo('log-router', 'Server ‚Üì: {"type":"CHAT_MSG", "text":"Hello world"}', 'rx');
        setTimeout(() => logTo('log-router', 'Router  ‚Üí: Executed renderMessage("Hello world")', 'sys'), 100);
      } else if(action === 'TYPING') {
        logTo('log-router', 'Server ‚Üì: {"type":"USER_TYPING", "user":"Alice"}', 'rx');
        setTimeout(() => logTo('log-router', 'Router  ‚Üí: Executed showIndicator("Alice")', 'sys'), 100);
      } else {
        logTo('log-router', 'Server ‚Üì: {"type":"LEGACY_PING", "data":"0"}', 'rx');
        setTimeout(() => logTo('log-router', 'Router  ‚Üí: WARNING - Unknown event type: LEGACY_PING', 'err'), 100);
      }
    }

    // --- 2. Guard Simulator ---
    let spamCount = 0;
    function simGuard(action) {
      if(action === 'VALID') {
        logTo('log-guard', 'Client ‚Üë: {"action": "SAVE"}', 'tx');
        setTimeout(() => logTo('log-guard', 'Guard 1 : Rate Limit OK', 'sys'), 200);
        setTimeout(() => logTo('log-guard', 'Guard 2 : Auth Token OK', 'sys'), 400);
        setTimeout(() => logTo('log-guard', 'Router  : Passing to core logic...', 'rx'), 600);
      } else {
        logTo('log-guard', 'Client ‚Üë: {"action": "SPAM_MESSAGE"}', 'tx');
        setTimeout(() => logTo('log-guard', 'Guard 1 : ERROR - Rate limit exceeded! (Denying packet)', 'err'), 100);
      }
    }

    // --- 3. Watchdog Simulator ---
    let watchdogTimer = null;
    let serverInterval = null;
    let isGhosted = false;

    function resetDog() {
      clearTimeout(watchdogTimer);
      if(!isGhosted) {
        logTo('log-watchdog', 'Client  : Watchdog reset! Waiting 4s max...', 'sys');
      }
      watchdogTimer = setTimeout(() => {
        logTo('log-watchdog', 'Client  : FATAL - No heartbeat for 4s. Forcing ws.close()!', 'err');
        clearInterval(serverInterval);
      }, 4000);
    }

    function simWatchdog(action) {
      document.getElementById('log-watchdog').innerHTML = '';
      clearInterval(serverInterval);
      clearTimeout(watchdogTimer);
      isGhosted = false;

      if(action === 'START') {
        logTo('log-watchdog', 'Client  : Connected. Watchdog started (Wait = 4s)', 'sys');
        resetDog();
        serverInterval = setInterval(() => {
          if(isGhosted) return;
          logTo('log-watchdog', 'Server ‚Üì: {"type":"PING"}', 'rx');
          resetDog();
        }, 2000);
      } else {
        isGhosted = true;
        logTo('log-watchdog', 'Server  : *Physical cable severed silently*', 'err');
      }
    }

    // --- 4. Req/Res Simulator ---
    const awaits = new Map();
    function simReqRes(action) {
      const reqId = "req_" + Math.random().toString(36).substr(2, 4);
      logTo('log-reqres', `Client ‚Üë: fetchUser() called. Map.set('${reqId}', Promise_1)`, 'sys');
      logTo('log-reqres', `Client ‚Üë: {"reqId":"${reqId}", "action":"FETCH"}`, 'tx');
      
      const delay = action === 'DB_SLOW' ? 2500 : 400;
      
      setTimeout(() => {
        logTo('log-reqres', `Server ‚Üì: {"reqId":"${reqId}", "data":"Bob"}`, 'rx');
        logTo('log-reqres', `Client  : Map.delete('${reqId}') -> Promise_1 explicitly resolved!`, 'sys');
      }, delay);
    }

  </script>
</body>
</html>
