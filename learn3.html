<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lesson 3 ‚Äî Callbacks vs Async/Await</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap"
    rel="stylesheet" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

            :root {
      --bg: #ffffff;
      --card: #f8fafc;
      --card2: #f1f5f9;
      --border: #e2e8f0;
      --text: #0f172a;
      --muted: #64748b;
      --dim: #475569;
      --green: #16a34a;
      --blue: #0284c7;
      --purple: #7c3aed;
      --yellow: #ca8a04;
      --red: #dc2626;
      --orange: #ea580c;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }

    .hero {
      text-align: center;
      padding: 60px 24px 44px;
      background: radial-gradient(ellipse 80% 60% at 50% 0%, rgba(251, 191, 36, .07), transparent);
      border-bottom: 1px solid var(--border);
    }

    .hero-tag {
      display: inline-block;
      background: rgba(251, 191, 36, .1);
      color: var(--yellow);
      border: 1px solid rgba(251, 191, 36, .25);
      border-radius: 99px;
      padding: 4px 14px;
      font-size: .75rem;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 20px;
    }

    .hero h1 {
      font-size: clamp(2rem, 5vw, 3.2rem);
      font-weight: 800;
      margin-bottom: 14px;
      background: linear-gradient(135deg, #e2e8f0, #94a3b8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .hero p {
      font-size: 1rem;
      color: var(--dim);
      max-width: 560px;
      margin: 0 auto;
    }

    .page {
      max-width: 880px;
      margin: 0 auto;
      padding: 48px 24px;
      display: flex;
      flex-direction: column;
      gap: 52px;
    }

    .sec-label {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 22px;
    }

    .sec-num {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: .8rem;
      font-weight: 700;
      flex-shrink: 0;
    }

    .sec-title {
      font-size: 1.2rem;
      font-weight: 700;
    }

    .sec-sub {
      font-size: .84rem;
      color: var(--muted);
      margin-top: 2px;
    }

    /* ANALOGY split */
    .two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
    }

    @media(max-width:700px) {
      .two-col {
        grid-template-columns: 1fr;
      }
    }

    .box {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
    }

    .box-head {
      padding: 14px 18px;
      border-bottom: 1px solid var(--border);
      font-weight: 700;
      font-size: .95rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .box-body {
      padding: 18px;
    }

    .box-body p {
      font-size: .88rem;
      color: var(--dim);
      line-height: 1.7;
    }

    .highlight {
      margin-top: 12px;
      padding: 12px 14px;
      border-radius: 8px;
      border-left: 3px solid;
      font-size: .84rem;
      color: var(--dim);
      line-height: 1.7;
    }

    .highlight.hl-red {
      border-color: var(--red);
      background: rgba(248, 113, 113, .05);
    }

    .highlight.hl-green {
      border-color: var(--green);
      background: rgba(34, 197, 94, .05);
    }

    .highlight.hl-orange {
      border-color: var(--orange);
      background: rgba(251, 146, 60, .05);
    }

    /* section number colours */
    .sec-num.c-yellow {
      background: rgba(251, 191, 36, .15);
      color: var(--yellow);
    }

    .sec-num.c-orange {
      background: rgba(251, 146, 60, .15);
      color: var(--orange);
    }

    .sec-num.c-green {
      background: rgba(34, 197, 94, .15);
      color: var(--green);
    }

    .sec-num.c-blue {
      background: rgba(56, 189, 248, .15);
      color: var(--blue);
    }

    .sec-num.c-purple {
      background: rgba(167, 139, 250, .15);
      color: var(--purple);
    }

    /* box-head colour helpers */
    .box-head.c-yellow {
      color: var(--yellow);
    }

    .box-head.c-orange {
      color: var(--orange);
    }

    .box-head.c-green {
      color: var(--green);
    }

    .box-head.c-purple {
      color: var(--purple);
    }

    .box-head.c-red {
      color: var(--red);
    }

    /* demo card border colours */
    .demo-card.bc-orange {
      border-color: rgba(251, 146, 60, .25);
    }

    .demo-card.bc-green {
      border-color: rgba(34, 197, 94, .25);
    }

    /* small label helpers */
    .label-orange {
      font-size: .95rem;
      font-weight: 700;
      color: var(--orange);
    }

    .label-green {
      font-size: .95rem;
      font-weight: 700;
      color: var(--green);
    }

    .label-red {
      font-size: .8rem;
      font-weight: 700;
      color: var(--red);
      margin-bottom: 8px;
    }

    .label-green2 {
      font-size: .8rem;
      font-weight: 700;
      color: var(--green);
      margin-bottom: 8px;
    }

    .note-mt {
      margin-top: 14px;
    }

    .note-mb {
      margin-bottom: 14px;
    }

    .note-sm {
      font-size: .84rem;
      color: var(--dim);
    }

    strong.c-red {
      color: var(--red);
    }

    strong.c-green {
      color: var(--green);
    }

    /* CODE BLOCKS */
    .code {
      font-family: 'Fira Code', monospace;
      font-size: .78rem;
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 14px;
      color: #334155;
      overflow-x: auto;
      margin-top: 14px;
      line-height: 1.9;
    }

    .kw {
      color: #0284c7;
    }

    .fn {
      color: #16a34a;
    }

    .str {
      color: #dc2626;
    }

    .cm {
      color: #475569;
      font-style: italic;
    }

    .bad {
      color: #f87171;
    }

    .good {
      color: #16a34a;
    }

    /* PYRAMID (callback hell visualization) */
    .pyramid {
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .py-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 9px 14px;
      background: var(--card2);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 4px;
      font-family: 'Fira Code', monospace;
      font-size: .78rem;
      color: var(--dim);
      transition: background .3s;
    }

    .py-row .indent {
      color: var(--border);
      flex-shrink: 0;
    }

    .py-row .arrow {
      color: var(--orange);
      flex-shrink: 0;
    }

    .py-row.highlight-row {
      background: rgba(248, 113, 113, .08);
      border-color: rgba(248, 113, 113, .3);
    }

    /* INTERACTIVE DEMO */
    .demo-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .task-row {
      display: flex;
      align-items: center;
      gap: 12px;
      background: var(--card2);
      border-radius: 10px;
      padding: 12px 16px;
      font-size: .88rem;
    }

    .task-icon {
      font-size: 1.4rem;
      flex-shrink: 0;
    }

    .task-status {
      flex: 1;
    }

    .task-label {
      font-weight: 600;
    }

    .task-note {
      font-size: .78rem;
      color: var(--muted);
      margin-top: 2px;
    }

    .task-badge {
      font-size: .72rem;
      font-weight: 700;
      padding: 3px 10px;
      border-radius: 99px;
      flex-shrink: 0;
    }

    .badge-wait {
      background: rgba(100, 116, 139, .15);
      color: var(--muted);
    }

    .badge-running {
      background: rgba(251, 191, 36, .15);
      color: var(--yellow);
    }

    .badge-done {
      background: rgba(34, 197, 94, .15);
      color: var(--green);
    }

    .btn-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 18px;
      border-radius: 8px;
      border: none;
      font-family: 'Inter', sans-serif;
      font-size: .85rem;
      font-weight: 600;
      cursor: pointer;
      transition: opacity .2s, transform .1s;
    }

    .btn:hover:not(:disabled) {
      opacity: .85;
      transform: translateY(-1px);
    }

    .btn:disabled {
      opacity: .35;
      cursor: not-allowed;
    }

    .btn-yellow {
      background: var(--yellow);
      color: #451a03;
    }

    .btn-green {
      background: var(--green);
      color: #052e16;
    }

    .btn-ghost {
      background: var(--card2);
      color: var(--dim);
      border: 1px solid var(--border);
    }

    .explain {
      background: rgba(56, 189, 248, .05);
      border: 1px solid rgba(56, 189, 248, .18);
      border-radius: 10px;
      padding: 14px 16px;
      font-size: .86rem;
      color: var(--dim);
      line-height: 1.7;
      display: none;
    }

    .explain.show {
      display: block;
    }

    .explain strong {
      color: var(--blue);
    }

    /* SUMMARY */
    .summary {
      background: rgba(167, 139, 250, .05);
      border: 1px solid rgba(167, 139, 250, .2);
      border-radius: 14px;
      padding: 20px 22px;
    }

    .summary h3 {
      font-size: 1rem;
      color: var(--purple);
      margin-bottom: 12px;
    }

    .compare-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      margin-top: 14px;
    }

    @media(max-width:600px) {
      .compare-row {
        grid-template-columns: 1fr;
      }
    }

    .cmp-item {
      background: var(--card2);
      border-radius: 10px;
      padding: 14px;
    }

    .cmp-title {
      font-size: .8rem;
      font-weight: 700;
      margin-bottom: 6px;
    }

    .cmp-body {
      font-size: .8rem;
      color: var(--dim);
      line-height: 1.65;
    }

    /* CHEATSHEET */
    .cheat-wrap {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: .83rem;
    }

    th {
      padding: 10px 14px;
      background: var(--card2);
      color: var(--dim);
      font-weight: 600;
      font-size: .75rem;
      text-transform: uppercase;
      letter-spacing: .4px;
      border-bottom: 1px solid var(--border);
      text-align: left;
    }

    td {
      padding: 10px 14px;
      border-bottom: 1px solid var(--border);
      color: var(--dim);
      vertical-align: top;
    }

    td:first-child {
      font-family: 'Fira Code', monospace;
      color: var(--blue);
      font-size: .78rem;
    }

    tr:last-child td {
      border-bottom: none;
    }

    .nav-bar {
      display: flex;
      gap: 12px;
      justify-content: center;
      padding: 24px;
      border-top: 1px solid var(--border);
      margin-top: 16px;
    }

    .nav-btn {
      padding: 10px 22px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-family: 'Inter', sans-serif;
      font-size: .85rem;
      font-weight: 600;
      background: var(--card);
      color: var(--dim);
      cursor: pointer;
      text-decoration: none;
      transition: border-color .2s, color .2s;
    }

    .nav-btn:hover {
      border-color: var(--purple);
      color: var(--text);
    }

    .nav-btn.primary {
      background: var(--purple);
      color: #1a0a2e;
      border-color: var(--purple);
    }
  
    /* ‚îÄ‚îÄ MOBILE RESPONSIVE ‚îÄ‚îÄ */
    @media (max-width: 768px) {
      .hero h1 { font-size: 1.6rem !important; }
      .hero p { font-size: .88rem !important; }
      .page { padding: 24px 16px !important; }
      .two-col { grid-template-columns: 1fr !important; }
      .stats { flex-wrap: wrap; gap: 12px; }
      .code, pre { font-size: .7rem !important; }
      .nav-bar, [style*="justify-content:center"][style*="padding:24px"] { 
        flex-direction: column; align-items: center; 
      }
    }
    @media (max-width: 480px) {
      .hero { padding: 40px 16px 32px !important; }
      .hero h1 { font-size: 1.3rem !important; }
      section { margin-bottom: 24px !important; }
    }
</style>
  <script src="config.js"></script>
  <script src="progress.js"></script>
  
</head>

<body>

  <div class="hero">
    <div class="hero-tag">üéì Lesson 3</div>
    <h1>Callbacks vs Async/Await</h1>
    <p>Both do the same job ‚Äî wait for something to finish, then do something else. But one leads to chaos, and the
      other is clean and modern.</p>
  
  <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:16px">
    <span style="display:inline-flex;align-items:center;gap:5px;padding:5px 14px;border-radius:99px;font-size:.76rem;font-weight:700;background:rgba(255,255,255,.03);color:var(--dim);border:1px solid #22c55e30">üü¢ Beginner</span>
    <span style="display:inline-flex;align-items:center;gap:5px;padding:5px 14px;border-radius:99px;font-size:.76rem;font-weight:600;background:rgba(255,255,255,.03);color:var(--text);border:1px solid rgba(255,255,255,0.06)">‚è±Ô∏è ~10 min read</span>
    <a href="learn2.html" style="display:inline-flex;align-items:center;gap:5px;padding:5px 14px;border-radius:99px;font-size:.76rem;font-weight:600;background:rgba(255,255,255,.03);color:var(--text);border:1px solid rgba(255,255,255,0.06);text-decoration:none">üîó Prereq: Lesson 2: Listeners</a>
  </div>
</div>

  <div class="page">

    <!-- ‚ë† THE CORE PROBLEM -->
    <section>
      <div class="sec-label">
        <div class="sec-num c-yellow">1</div>
        <div>
          <div class="sec-title">The Problem: Waiting ‚è≥</div>
          <div class="sec-sub">Code runs top-to-bottom instantly ‚Äî but some things take time</div>
        </div>
      </div>

      <div class="box">
        <div class="box-head c-yellow">‚ö†Ô∏è The issue every developer faces</div>
        <div class="box-body">
          <p>Imagine you go to a restaurant. You order food. The chef doesn't cook it instantly ‚Äî it takes 5 minutes.
            You have two choices:</p>
          <div class="highlight hl-red">
            <strong class="c-red">‚ùå Bad way:</strong> Stand frozen at the counter staring at the kitchen, doing nothing
            until food arrives. (This would freeze your entire browser!)
          </div>
          <div class="highlight hl-green">
            <strong class="c-green">‚úÖ Good way:</strong> Give the chef your number, go sit down, live your life. The
            chef <em>calls you back</em> when your food is ready. That's a <strong>Callback</strong> ‚Äî or more modernly,
            <strong>Async/Await</strong>.
          </div>
          <p class="note-mt">In WebSockets, sending a message and waiting for a server response is the same situation.
            You need to <strong>not freeze</strong> while waiting.</p>
        </div>
      </div>
    </section>

    <!-- ‚ë° CALLBACKS -->
    <section>
      <div class="sec-label">
        <div class="sec-num c-orange">2</div>
        <div>
          <div class="sec-title">Pattern 3: Callbacks üìû</div>
          <div class="sec-sub">The OLD way ‚Äî still works, but gets messy fast</div>
        </div>
      </div>

      <div class="two-col">
        <div>
          <div class="box">
            <div class="box-head c-orange">üìû Real life analogy</div>
            <div class="box-body">
              <p>You're calling a friend. You say: <em>"Order the pizza for me, and when it arrives, <strong>call me
                    back</strong> so I can come eat."</em></p>
              <div class="highlight hl-orange">
                You pass your friend a <strong>function</strong> (your callback) and say: "Run this when the task is
                done." The friend decides WHEN to call it.
              </div>
            </div>
          </div>
        </div>
        <div>
          <div class="box">
            <div class="box-head c-orange">üíª In code</div>
            <div class="box-body">
              <div class="code">
                <span class="cm">// You pass a callback function as an argument</span><br>
                <span class="kw">function</span> <span class="fn">processData</span>(data, <strong>callback</strong>)
                {<br>
                &nbsp;&nbsp;<span class="cm">// Simulates 600ms of "work"</span><br>
                &nbsp;&nbsp;<span class="fn">setTimeout</span>(() => {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="cm">// "Hey, I'm done! Here's your result"</span><br>
                &nbsp;&nbsp;&nbsp;&nbsp;<strong>callback</strong>(<span class="kw">null</span>, { result: data });<br>
                &nbsp;&nbsp;}, 600);<br>
                }<br><br>
                <span class="cm">// You define WHAT to do when done</span><br>
                <span class="fn">processData</span>(<span class="str">"hello"</span>, (err, result) => {<br>
                &nbsp;&nbsp;<span class="fn">console</span>.<span class="fn">log</span>(result); <span class="cm">//
                  runs after 600ms</span><br>
                });
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Callback Hell -->
      <div class="note-mt">
        <div class="box">
          <div class="box-head c-red">üò± The Problem: Callback Hell</div>
          <div class="box-body">
            <p class="note-mb">What if you need to do 3 things <em>in order</em>, each waiting for the previous? Your
              code becomes a pyramid of doom ‚Äî hard to read and impossible to fix:</p>
            <div class="pyramid">
              <div class="py-row"><span class="arrow">‚ñ∂</span> getUser("Alice", (err, user) => {</div>
              <div class="py-row highlight-row"><span class="indent">‚îÄ‚îÄ</span><span class="arrow">‚ñ∂</span>
                getOrders(user.id, (err, orders) => {</div>
              <div class="py-row highlight-row"><span class="indent">‚îÄ‚îÄ‚îÄ‚îÄ</span><span class="arrow">‚ñ∂</span>
                getDetails(orders[0], (err, detail) => {</div>
              <div class="py-row highlight-row"><span class="indent">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span><span class="arrow">‚ñ∂</span> <span
                  class="bad">// We're 6 levels deep! This is "callback hell" üò±</span></div>
              <div class="py-row"><span class="indent">‚îÄ‚îÄ‚îÄ‚îÄ</span>});</div>
              <div class="py-row"><span class="indent">‚îÄ‚îÄ</span>});</div>
              <div class="py-row">});</div>
            </div>
            <p class="note-mt note-sm">This is the <strong>exact reason</strong> async/await was invented. Let's see how
              it solves this.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- ‚ë¢ ASYNC/AWAIT -->
    <section>
      <div class="sec-label">
        <div class="sec-num c-green">3</div>
        <div>
          <div class="sec-title">Pattern 4: Async / Await ‚ú®</div>
          <div class="sec-sub">The MODERN way ‚Äî same result, reads like normal English</div>
        </div>
      </div>

      <div class="two-col">
        <div>
          <div class="box">
            <div class="box-head c-green">üõë Real life analogy</div>
            <div class="box-body">
              <p>You're in a drive-thru. You order and the cashier says: <em>"Please pull forward and <strong>wait
                    here</strong>."</em></p>
              <div class="highlight hl-green">
                <code>await</code> means: <em>"Pause right here until you get the result, then continue on to the next
                  line."</em> The code reads top-to-bottom just like normal! No nesting at all.
              </div>
            </div>
          </div>
        </div>
        <div>
          <div class="box">
            <div class="box-head c-green">üíª In code</div>
            <div class="box-body">
              <div class="code">
                <span class="cm">// "async" = this function can use await</span><br>
                <span class="kw">async function</span> <span class="fn">handleMessage</span>(data) {<br>
                &nbsp;&nbsp;<span class="kw">try</span> {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="cm">// "await" = pause here until done ‚úã</span><br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="kw">const</span> result = <span class="kw">await</span> <span
                  class="fn">processData</span>(data);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="cm">// Continues here after 600ms ‚ñ∂</span><br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="fn">console</span>.<span class="fn">log</span>(result);<br>
                &nbsp;&nbsp;} <span class="kw">catch</span> (err) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="fn">console</span>.<span class="fn">log</span>(<span
                  class="str">"Error:"</span>, err);<br>
                &nbsp;&nbsp;}<br>
                }
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Side by side comparison -->
      <div class="note-mt">
        <div class="box">
          <div class="box-head c-purple">‚öñÔ∏è Same task, two styles ‚Äî side by side</div>
          <div class="box-body">
            <div class="two-col">
              <div>
                <p class="label-red">‚ùå Callbacks (3 steps)</p>
                <div class="code">
                  <span class="fn">getUser</span>(<span class="str">"Alice"</span>, (err, user) => {<br>
                  &nbsp;&nbsp;<span class="fn">getOrders</span>(user.id, (err, orders) => {<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<span class="fn">getDetails</span>(orders[0], (err, detail) => {<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="fn">console</span>.<span
                    class="fn">log</span>(detail); <span class="cm">// üòµ</span><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;});<br>
                  &nbsp;&nbsp;});<br>
                  });
                </div>
              </div>
              <div>
                <p class="label-green2">‚úÖ Async/Await (3 steps)</p>
                <div class="code">
                  <span class="kw">const</span> user = <span class="kw">await</span> <span
                    class="fn">getUser</span>(<span class="str">"Alice"</span>);<br>
                  <span class="kw">const</span> orders = <span class="kw">await</span> <span
                    class="fn">getOrders</span>(user.id);<br>
                  <span class="kw">const</span> detail = <span class="kw">await</span> <span
                    class="fn">getDetails</span>(orders[0]);<br>
                  <span class="fn">console</span>.<span class="fn">log</span>(detail); <span class="cm">// üòä
                    clean!</span>
                </div>
              </div>
            </div>
            <p class="note-mt note-sm">‚úÖ Async/Await does <em>exactly the same work</em> but reads like a shopping list
              instead of a maze!</p>
          </div>
        </div>
      </div>
    </section>

    <!-- ‚ë£ INTERACTIVE DEMO -->
    <section>
      <div class="sec-label">
        <div class="sec-num c-blue">4</div>
        <div>
          <div class="sec-title">‚ñ∂Ô∏è Try it ‚Äî Watch Both Run Live</div>
          <div class="sec-sub">Both simulate 800ms of processing (like a server doing work)</div>
        </div>
      </div>

      <div class="two-col">

        <!-- Callback Demo -->
        <div class="demo-card bc-orange">
          <div class="label-orange">üìû Callback Style</div>

          <div class="task-row">
            <div class="task-icon">üì§</div>
            <div class="task-status">
              <div class="task-label">Send to server</div>
              <div class="task-note">processWithCallback(data, cb)</div>
            </div>
            <div class="task-badge" id="cb-badge1">waiting</div>
          </div>
          <div class="task-row">
            <div class="task-icon">‚öôÔ∏è</div>
            <div class="task-status">
              <div class="task-label">Server processing...</div>
              <div class="task-note">setTimeout 800ms inside callback</div>
            </div>
            <div class="task-badge" id="cb-badge2">waiting</div>
          </div>
          <div class="task-row">
            <div class="task-icon">üì•</div>
            <div class="task-status">
              <div class="task-label">Callback fires with result</div>
              <div class="task-note">(err, result) => { ... }</div>
            </div>
            <div class="task-badge" id="cb-badge3">waiting</div>
          </div>

          <div class="btn-row">
            <button class="btn btn-yellow" id="btn-cb" onclick="runCallback()">Run Callback</button>
            <button class="btn btn-ghost" onclick="resetCallback()">Reset</button>
          </div>
          <div class="explain" id="explain-cb"></div>
        </div>

        <!-- Async/Await Demo -->
        <div class="demo-card bc-green">
          <div class="label-green">‚ú® Async/Await Style</div>

          <div class="task-row">
            <div class="task-icon">üì§</div>
            <div class="task-status">
              <div class="task-label">Send to server</div>
              <div class="task-note">await processWithPromise(data)</div>
            </div>
            <div class="task-badge" id="aw-badge1">waiting</div>
          </div>
          <div class="task-row">
            <div class="task-icon">‚öôÔ∏è</div>
            <div class="task-status">
              <div class="task-label">Server processing...</div>
              <div class="task-note">Promise resolves after 800ms</div>
            </div>
            <div class="task-badge" id="aw-badge2">waiting</div>
          </div>
          <div class="task-row">
            <div class="task-icon">üì•</div>
            <div class="task-status">
              <div class="task-label">await resumes with result</div>
              <div class="task-note">const result = await ...</div>
            </div>
            <div class="task-badge" id="aw-badge3">waiting</div>
          </div>

          <div class="btn-row">
            <button class="btn btn-green" id="btn-aw" onclick="runAsync()">Run Async/Await</button>
            <button class="btn btn-ghost" onclick="resetAsync()">Reset</button>
          </div>
          <div class="explain" id="explain-aw"></div>
        </div>

      </div>
    </section>

    <!-- ‚ë§ SUMMARY TABLE -->
    <section>
      <div class="sec-label">
        <div class="sec-num c-purple">5</div>
        <div>
          <div class="sec-title">üìã Quick Comparison</div>
          <div class="sec-sub">Remember this for your exams and interviews!</div>
        </div>
      </div>

      <div class="cheat-wrap">
        <table>
          <thead>
            <tr>
              <th></th>
              <th>üìû Callbacks</th>
              <th>‚ú® Async/Await</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Style</td>
              <td>Pass a function as argument</td>
              <td>Write with await keyword</td>
            </tr>
            <tr>
              <td>Readability</td>
              <td>‚ùå Pyramid / nested mess</td>
              <td>‚úÖ Reads top to bottom</td>
            </tr>
            <tr>
              <td>Error handling</td>
              <td>Manual if(err) every time</td>
              <td>Clean try/catch block</td>
            </tr>
            <tr>
              <td>Chaining steps</td>
              <td>‚ùå Callback inside callback</td>
              <td>‚úÖ Just add another await</td>
            </tr>
            <tr>
              <td>Debug-friendly</td>
              <td>Hard ‚Äî stack traces messy</td>
              <td>Easy ‚Äî reads like sync code</td>
            </tr>
            <tr>
              <td>Used in</td>
              <td>Old Node.js libraries</td>
              <td>All modern JavaScript</td>
            </tr>
            <tr>
              <td>Verdict</td>
              <td>üò∞ Works but avoid it</td>
              <td>üòä Always prefer this!</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

  </div>



  <script>
    // ‚îÄ‚îÄ‚îÄ CALLBACK DEMO ‚îÄ‚îÄ‚îÄ
    function setBadge(id, type, text) {
      const el = document.getElementById(id);
      el.textContent = text;
      el.className = `task-badge badge-${type}`;
    }

    function showExplain(id, html) {
      const el = document.getElementById(id);
      el.innerHTML = html;
      el.className = 'explain show';
    }

    function runCallback() {
      document.getElementById('btn-cb').disabled = true;
      setBadge('cb-badge1', 'running', 'running...');
      showExplain('explain-cb', '<strong>Step 1:</strong> You called processData() and passed a callback function as the last argument. The server is now working. Your code handed control over to the callback system.');

      setTimeout(() => {
        setBadge('cb-badge1', 'done', 'done ‚úì');
        setBadge('cb-badge2', 'running', 'running...');
        showExplain('explain-cb', '<strong>Step 2:</strong> The server is processing for 800ms. Notice ‚Äî you did NOT write <code>await</code>. Instead you just passed a function and said "call me when done".');
      }, 200);

      setTimeout(() => {
        setBadge('cb-badge2', 'done', 'done ‚úì');
        setBadge('cb-badge3', 'running', 'running...');
      }, 600);

      setTimeout(() => {
        setBadge('cb-badge3', 'done', 'done ‚úì');
        showExplain('explain-cb', '<strong>Step 3 ‚Äî Callback Fired! üéâ</strong> After 800ms, the system called your function with <code>(null, result)</code>. The <code>null</code> means no error. You now have your result! This works ‚Äî but imagine 5 of these nested inside each other...');
      }, 1000);
    }

    function resetCallback() {
      ['cb-badge1', 'cb-badge2', 'cb-badge3'].forEach(id => setBadge(id, 'wait', 'waiting'));
      document.getElementById('explain-cb').className = 'explain';
      document.getElementById('btn-cb').disabled = false;
    }

    // ‚îÄ‚îÄ‚îÄ ASYNC/AWAIT DEMO ‚îÄ‚îÄ‚îÄ
    function runAsync() {
      document.getElementById('btn-aw').disabled = true;
      setBadge('aw-badge1', 'running', 'running...');
      showExplain('explain-aw', '<strong>Step 1:</strong> You wrote <code>await processData(data)</code>. The <code>await</code> keyword tells JavaScript: "Pause here and wait for the result." The function is async so it returns a Promise.');

      setTimeout(() => {
        setBadge('aw-badge1', 'done', 'done ‚úì');
        setBadge('aw-badge2', 'running', 'running...');
        showExplain('explain-aw', '<strong>Step 2:</strong> The Promise is pending ‚Äî server is working. The <code>await</code> is patiently waiting. Notice how no nesting is happening! The code just paused at that one line.');
      }, 200);

      setTimeout(() => {
        setBadge('aw-badge2', 'done', 'done ‚úì');
        setBadge('aw-badge3', 'running', 'running...');
      }, 600);

      setTimeout(() => {
        setBadge('aw-badge3', 'done', 'done ‚úì');
        showExplain('explain-aw', '<strong>Step 3 ‚Äî Await Resumed! üéâ</strong> The Promise resolved! The <code>await</code> unpaused and returned the value directly into <code>const result = ...</code>. Clean, flat and readable. Error handling is just a <code>try/catch</code>. This is why modern code uses async/await!');
      }, 1000);
    }

    function resetAsync() {
      ['aw-badge1', 'aw-badge2', 'aw-badge3'].forEach(id => setBadge(id, 'wait', 'waiting'));
      document.getElementById('explain-aw').className = 'explain';
      document.getElementById('btn-aw').disabled = false;
    }
  </script>


  

  

  
  

  <div style="display:flex;gap:12px;align-items:flex-start;padding:10px 14px;background:rgba(255,255,255,0.02);border-radius:10px;border:1px solid rgba(255,255,255,0.06)">
          <span style="font-size:1.3rem;flex-shrink:0;margin-top:2px">üì¶</span>
          <div>
            <div style="font-weight:700;font-size:.85rem;color:var(--text);margin-bottom:3px">npm / Yarn</div>
            <div style="font-size:.82rem;color:#94a3b8;line-height:1.6">Package managers use async patterns to download multiple dependencies concurrently. Callbacks would create deeply nested "dependency hell."</div>
          </div>
        </div>
        <div style="display:flex;gap:12px;align-items:flex-start;padding:10px 14px;background:rgba(255,255,255,0.02);border-radius:10px;border:1px solid rgba(255,255,255,0.06)">
          <span style="font-size:1.3rem;flex-shrink:0;margin-top:2px">‚òÅÔ∏è</span>
          <div>
            <div style="font-weight:700;font-size:.85rem;color:var(--text);margin-bottom:3px">AWS SDK (v3)</div>
            <div style="font-size:.82rem;color:#94a3b8;line-height:1.6">Amazon rewrote their entire JavaScript SDK from callbacks to async/await because developers found callbacks too error-prone for complex cloud operations.</div>
          </div>
        </div>
        <div style="display:flex;gap:12px;align-items:flex-start;padding:10px 14px;background:rgba(255,255,255,0.02);border-radius:10px;border:1px solid rgba(255,255,255,0.06)">
          <span style="font-size:1.3rem;flex-shrink:0;margin-top:2px">üîÑ</span>
          <div>
            <div style="font-weight:700;font-size:.85rem;color:var(--text);margin-bottom:3px">Next.js Server Components</div>
            <div style="font-size:.82rem;color:#94a3b8;line-height:1.6">React Server Components use <code>async/await</code> to fetch data on the server. No useEffect callbacks ‚Äî just clean, linear code.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<!-- ‚úÖ MARK COMPLETE -->
  <div style="max-width:880px;margin:0 auto;padding:0 24px 20px">
    <button id="markCompleteBtn" onclick="toggleLessonComplete()" style="width:100%;padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,.03);color:var(--dim);font-family:Inter,sans-serif;font-size:.9rem;font-weight:700;cursor:pointer;transition:all .2s;display:flex;align-items:center;justify-content:center;gap:8px">
      <span id="markCompleteIcon">‚òê</span>
      <span id="markCompleteText">Mark Lesson 3 as Complete</span>
    </button>
  </div>
  <script>
    function toggleLessonComplete() {
      const result = WSProgress.toggleComplete(3);
      updateCompleteButton(result.isComplete);
    }
    function updateCompleteButton(isComplete) {
      const btn = document.getElementById('markCompleteBtn');
      const icon = document.getElementById('markCompleteIcon');
      const text = document.getElementById('markCompleteText');
      if (isComplete) {
        btn.style.background = 'rgba(34,197,94,.18)';
        btn.style.borderColor = '#22c55e';
        icon.textContent = '‚úÖ';
        text.textContent = 'Lesson 3 Complete!';
      } else {
        btn.style.background = 'rgba(34,197,94,.08)';
        btn.style.borderColor = '#22c55e';
        icon.textContent = '‚òê';
        text.textContent = 'Mark Lesson 3 as Complete';
      }
    }
    // Check on load
    document.addEventListener('DOMContentLoaded', () => {
      const completed = WSProgress.getCompleted();
      updateCompleteButton(completed.has(3));
    });
  </script>


  </div>

  
  <!-- üèóÔ∏è STORY-DRIVEN SCENARIO IMPLEMENTATION -->
  <div style="max-width:880px;margin:0 auto;padding:0 24px 28px">
    <div style="background:var(--card);border:1px solid var(--border);border-radius:14px;overflow:hidden; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);">
      <div style="padding:16px 20px;border-bottom:1px solid var(--border);font-weight:700;font-size:1.05rem;color:var(--text);display:flex;align-items:center;gap:8px; background:var(--card2)">
        <span>üèóÔ∏è</span>
        <span>Scenario 1: AI Chatbot Response Streaming (ChatGPT / Claude)</span>
      </div>
      <div style="padding:20px">
        <div style="margin-bottom:22px">
          <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:1px;font-weight:700;color:var(--blue);margin-bottom:8px">üìñ The End-to-End Story</div>
          <div style="font-size:.9rem;color:var(--dim);line-height:1.75">**The Business Problem:** Large Language Models (LLMs) take several seconds to generate a full response. If the frontend uses a standard HTTP request, the user stares at a blank loading spinner for 10 seconds before a massive block of text suddenly appears. This creates a terrible user experience that feels slow and broken.<br><br>**The End-to-End Flow:** The frontend architects use WebSockets to stream the AI's response 'token by token' (word by word) as it's being generated by the GPU on the backend. However, dealing with asynchronous network chunks using traditional nested callbacks creates deeply confusing 'spaghetti code'. Instead, the architects wrap the entire WebSocket lifecycle inside a modern JavaScript `Promise`. This allows the UI engineers to write clean, linear `async/await` code. They request the prompt and simply `await` the resolving promise, which acts as a bucket that quietly collects the chunks in the background until the server sends the final `[DONE]` signal.</div>
        </div>
        <div>
          <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:1px;font-weight:700;color:var(--blue);margin-bottom:8px">üíª Implementation Code</div>
          <pre style="margin:0;padding:16px;background:#f8fafc;border:1px solid var(--border);border-radius:8px;font-family:'Fira Code',monospace;font-size:.8rem;color:#334155;overflow-x:auto;line-height:1.8"><code>// 1. We encapsulate the messy WebSocket logic inside an Async Promise
async function fetchAIResponseStream(promptText) {
  return new Promise((resolve, reject) =&gt; {
    const ws = new WebSocket('wss://ai-engine.tech/generate');
    let completeResponse = ""; // Our bucket to hold the chunks

    // When connection opens, send the user's prompt
    ws.onopen = () =&gt; ws.send(JSON.stringify({ prompt: promptText }));
    
    // As the GPU spits out words, they arrive here instantly
    ws.onmessage = (event) =&gt; {
      const payload = JSON.parse(event.data);
      
      if (payload.status === 'GENERATING') {
        completeResponse += payload.token; // Append the new word
      } else if (payload.status === 'DONE') {
        ws.close(); // Clean up the network layer
        resolve(completeResponse); // We are finished! Return the full string.
      }
    };
    
    ws.onerror = (err) =&gt; reject("Network failure during generation");
  });
}

// 2. The UI code becomes incredibly clean and linear
async function handleUserSubmit() {
  showLoadingSpinner();
  try {
    // Execution pauses here until the Promise explicitly calls resolve()
    const answer = await fetchAIResponseStream("Explain Quantum Physics");
    renderFinalText(answer);
  } catch (error) {
    showErrorState();
  }
}</code></pre>
        </div>
      </div>
    </div>
  </div>

  <!-- üèóÔ∏è STORY-DRIVEN SCENARIO IMPLEMENTATION -->
  <div style="max-width:880px;margin:0 auto;padding:0 24px 28px">
    <div style="background:var(--card);border:1px solid var(--border);border-radius:14px;overflow:hidden; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);">
      <div style="padding:16px 20px;border-bottom:1px solid var(--border);font-weight:700;font-size:1.05rem;color:var(--text);display:flex;align-items:center;gap:8px; background:var(--card2)">
        <span>üèóÔ∏è</span>
        <span>Scenario 2: Long-Running Database Migration System</span>
      </div>
      <div style="padding:20px">
        <div style="margin-bottom:22px">
          <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:1px;font-weight:700;color:var(--blue);margin-bottom:8px">üìñ The End-to-End Story</div>
          <div style="font-size:.9rem;color:var(--dim);line-height:1.75">**The Business Problem:** An admin dashboard has a button to "Migrate 10 Million User Records." This backend process takes 45 minutes to complete. Standard HTTP requests timeout after 30-60 seconds. If an admin clicks the button, the browser will eventually show a '504 Gateway Timeout' error, even though the database is still churning away in the background. The admin has no idea if it succeeded or failed.<br><br>**The End-to-End Flow:** The button triggers a WebSocket connection instead of an HTTP POST. The backend begins the 45-minute loop, passing progress updates (1%, 15%, 50%) through the open socket every few seconds. By wrapping this in a Promise, the frontend JavaScript execution is cleanly halted in an `await` state for the entire 45 minutes. The Promise only resolves when the server definitively sends the `COMPLETE` packet, allowing the code to proceed and show the success modal automatically.</div>
        </div>
        <div>
          <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:1px;font-weight:700;color:var(--blue);margin-bottom:8px">üíª Implementation Code</div>
          <pre style="margin:0;padding:16px;background:#f8fafc;border:1px solid var(--border);border-radius:8px;font-family:'Fira Code',monospace;font-size:.8rem;color:#334155;overflow-x:auto;line-height:1.8"><code>async function triggerDatabaseMigration() {
  return new Promise((resolve, reject) =&gt; {
    const ws = new WebSocket('wss://admin-panel.internal/db/migrate');
    
    ws.onmessage = (event) =&gt; {
      const data = JSON.parse(event.data);
      
      // Update a visual progress bar while we wait
      if (data.type === 'PROGRESS') {
        updateProgressBarUI(data.percentComplete);
      }
      
      // The 45-minute task finished
      if (data.type === 'SUCCESS') {
        resolve("Migration completed successfully!");
      }
      
      // The task encountered a fatal database error
      if (data.type === 'FATAL_ERROR') {
        reject(data.errorMessage);
      }
    };
  });
}

// Button Click Handler
async function onMigrateClick() {
  btn.innerText = "Migrating...";
  try {
    // We can confidently wait here for 45 minutes without HTTP timeouts
    const resultMsg = await triggerDatabaseMigration();
    showConfetti(resultMsg);
  } catch (error) {
    showAlert(`Failed: ${error}`);
  }
}</code></pre>
        </div>
      </div>
    </div>
  </div>

  <!-- üèóÔ∏è STORY-DRIVEN SCENARIO IMPLEMENTATION -->
  <div style="max-width:880px;margin:0 auto;padding:0 24px 28px">
    <div style="background:var(--card);border:1px solid var(--border);border-radius:14px;overflow:hidden; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);">
      <div style="padding:16px 20px;border-bottom:1px solid var(--border);font-weight:700;font-size:1.05rem;color:var(--text);display:flex;align-items:center;gap:8px; background:var(--card2)">
        <span>üèóÔ∏è</span>
        <span>Scenario 3: Request-Response Correlation IDs (Microservices)</span>
      </div>
      <div style="padding:20px">
        <div style="margin-bottom:22px">
          <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:1px;font-weight:700;color:var(--blue);margin-bottom:8px">üìñ The End-to-End Story</div>
          <div style="font-size:.9rem;color:var(--dim);line-height:1.75">**The Business Problem:** WebSockets are inherently 'stateless' pipes. If you send a `GET_USER` request to the server, and two seconds later the server pushes a json object `{name: 'Alice'}`, the WebSocket protocol itself has no built-in way to prove that the Alice object is the direct answer to your specific `GET_USER` request. If you send five requests at once, the responses arrive jumbled.<br><br>**The End-to-End Flow:** To bridge the gap between traditional Request/Response paradigms and the wild west of Websockets, architects use 'Correlation IDs' paired with Promises. When the client wants data, it generates a unique UUID (e.g., 'req-123'), attaches it to the JSON payload, creates a Promise, and stores the Promise's `resolve` function in a global Map keyed by that exact UUID. When the server finishes processing, it echoes that exact UUID back in the payload. The client looks up 'req-123' in the Map, pulls out the specific `resolve` function, and triggers it, cleanly fulfilling the exact `await` block that asked for the data.</div>
        </div>
        <div>
          <div style="font-size:.75rem;text-transform:uppercase;letter-spacing:1px;font-weight:700;color:var(--blue);margin-bottom:8px">üíª Implementation Code</div>
          <pre style="margin:0;padding:16px;background:#f8fafc;border:1px solid var(--border);border-radius:8px;font-family:'Fira Code',monospace;font-size:.8rem;color:#334155;overflow-x:auto;line-height:1.8"><code>// 1. A global map to hold our pending Promise 'resolve' functions
const pendingRequests = new Map();
const ws = new WebSocket('wss://api.microservice.com');

// 2. The central listening hub routes answers to the correct waiting Promises
ws.onmessage = (event) =&gt; {
  const response = JSON.parse(event.data); // e.g. { reqId: "req-99", data: "Alice" }
  
  // Did we ask for this?
  if (pendingRequests.has(response.reqId)) {
    const resolveFunction = pendingRequests.get(response.reqId);
    resolveFunction(response.data); // Fulfill the specific awaited Promise
    pendingRequests.delete(response.reqId); // Clean up memory
  }
};

// 3. The wrapper generates IDs and traps the execution flow
async function fetchUserOverWebsocket(userId) {
  return new Promise((resolve) =&gt; {
    // Generate a unique identifier for this specific question
    const uniqueReqId = "req-" + Math.random().toString(36).substr(2, 9);
    
    // Store the resolve function in the map so onmessage can find it later
    pendingRequests.set(uniqueReqId, resolve);
    
    // Fire the question into the pipe
    ws.send(JSON.stringify({ 
      action: "FETCH_USER", 
      reqId: uniqueReqId, 
      targetUserId: userId 
    }));
  });
}

// 4. Usage looks identical to a standard HTTP fetch!
const userA = await fetchUserOverWebsocket(77); // Wait exactly for User 77's response
const userB = await fetchUserOverWebsocket(99);</code></pre>
        </div>
      </div>
    </div>
  </div>
<!-- üß† TEST YOURSELF QUIZ -->
  <div style="max-width:880px;margin:0 auto;padding:0 24px 32px">
    <div style="background:transparent;border:1px solid rgba(255,255,255,0.06);border-radius:14px;overflow:hidden">
      <div style="padding:14px 18px;border-bottom:1px solid #1f2d45;font-weight:700;font-size:.95rem;color:var(--text);display:flex;align-items:center;justify-content:space-between">
        <span>üß† Test Yourself</span>
        <span id="quiz_9817_score" style="font-size:.8rem;color:#94a3b8">0/4 answered</span>
      </div>
      <div style="padding:18px">
        <div id="quiz_9817_q0" style="margin-bottom:20px">
          <div style="font-size:.88rem;font-weight:600;color:var(--text);margin-bottom:10px">1. What is 'callback hell'?</div>
          <div style="display:flex;flex-direction:column;gap:6px">
            <button id="quiz_9817_q0_o0" onclick="quiz_9817_check(0,0)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">A. A JavaScript framework</button>
            <button id="quiz_9817_q0_o1" onclick="quiz_9817_check(0,1)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">B. Deeply nested callbacks that become unreadable</button>
            <button id="quiz_9817_q0_o2" onclick="quiz_9817_check(0,2)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">C. An error type in Node.js</button>
            <button id="quiz_9817_q0_o3" onclick="quiz_9817_check(0,3)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">D. A debugging tool</button>
          </div>
          <div id="quiz_9817_q0_explain" style="display:none;margin-top:8px;padding:10px 14px;border-radius:8px;font-size:.82rem;line-height:1.6"></div>
        </div>
        <div id="quiz_9817_q1" style="margin-bottom:20px">
          <div style="font-size:.88rem;font-weight:600;color:var(--text);margin-bottom:10px">2. What does the <code>await</code> keyword do?</div>
          <div style="display:flex;flex-direction:column;gap:6px">
            <button id="quiz_9817_q1_o0" onclick="quiz_9817_check(1,0)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">A. Creates a new thread</button>
            <button id="quiz_9817_q1_o1" onclick="quiz_9817_check(1,1)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">B. Pauses execution until the Promise resolves</button>
            <button id="quiz_9817_q1_o2" onclick="quiz_9817_check(1,2)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">C. Sends data to the server</button>
            <button id="quiz_9817_q1_o3" onclick="quiz_9817_check(1,3)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">D. Catches errors</button>
          </div>
          <div id="quiz_9817_q1_explain" style="display:none;margin-top:8px;padding:10px 14px;border-radius:8px;font-size:.82rem;line-height:1.6"></div>
        </div>
        <div id="quiz_9817_q2" style="margin-bottom:20px">
          <div style="font-size:.88rem;font-weight:600;color:var(--text);margin-bottom:10px">3. Where can you use <code>await</code>?</div>
          <div style="display:flex;flex-direction:column;gap:6px">
            <button id="quiz_9817_q2_o0" onclick="quiz_9817_check(2,0)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">A. Anywhere in JavaScript</button>
            <button id="quiz_9817_q2_o1" onclick="quiz_9817_check(2,1)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">B. Only inside async functions</button>
            <button id="quiz_9817_q2_o2" onclick="quiz_9817_check(2,2)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">C. Only in Node.js</button>
            <button id="quiz_9817_q2_o3" onclick="quiz_9817_check(2,3)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">D. Only in try/catch blocks</button>
          </div>
          <div id="quiz_9817_q2_explain" style="display:none;margin-top:8px;padding:10px 14px;border-radius:8px;font-size:.82rem;line-height:1.6"></div>
        </div>
        <div id="quiz_9817_q3" style="margin-bottom:20px">
          <div style="font-size:.88rem;font-weight:600;color:var(--text);margin-bottom:10px">4. How do you handle errors with async/await?</div>
          <div style="display:flex;flex-direction:column;gap:6px">
            <button id="quiz_9817_q3_o0" onclick="quiz_9817_check(3,0)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">A. if/else statements</button>
            <button id="quiz_9817_q3_o1" onclick="quiz_9817_check(3,1)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">B. Error-first callbacks</button>
            <button id="quiz_9817_q3_o2" onclick="quiz_9817_check(3,2)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">C. try/catch blocks</button>
            <button id="quiz_9817_q3_o3" onclick="quiz_9817_check(3,3)" style="text-align:left;padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#cbd5e1;font-family:Inter,sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onmouseover="this.style.borderColor='#a78bfa'" onmouseout="this.style.borderColor='#1f2d45'">D. .then().catch()</button>
          </div>
          <div id="quiz_9817_q3_explain" style="display:none;margin-top:8px;padding:10px 14px;border-radius:8px;font-size:.82rem;line-height:1.6"></div>
        </div>
      </div>
    </div>
  </div>
  <script>
    (function() {
      const answers = [1, 1, 1, 2];
      const explains = ['Callback hell is when callbacks are nested inside callbacks, creating a rightward-drifting pyramid of code.', '<code>await</code> pauses the async function at that line until the Promise resolves, then returns the value.', '<code>await</code> can only be used inside functions declared with the <code>async</code> keyword.', 'Wrap <code>await</code> calls in <code>try/catch</code> ‚Äî errors from rejected Promises are caught in the catch block.'];
      let answered = new Set();
      let correct = 0;
      window.quiz_9817_check = function(qi, oi) {
        if (answered.has(qi)) return;
        answered.add(qi);
        const isCorrect = oi === answers[qi];
        if (isCorrect) correct++;
        // Style the selected option
        const btn = document.getElementById("quiz_9817_q" + qi + "_o" + oi);
        btn.style.background = isCorrect ? "rgba(34,197,94,.15)" : "rgba(248,113,113,.15)";
        btn.style.borderColor = isCorrect ? "#22c55e" : "#f87171";
        btn.style.color = isCorrect ? "#22c55e" : "#f87171";
        btn.textContent = (isCorrect ? "‚úÖ " : "‚ùå ") + btn.textContent;
        // If wrong, highlight correct answer
        if (!isCorrect) {
          const correctBtn = document.getElementById("quiz_9817_q" + qi + "_o" + answers[qi]);
          correctBtn.style.background = "rgba(34,197,94,.15)";
          correctBtn.style.borderColor = "#22c55e";
          correctBtn.style.color = "#22c55e";
        }
        // Disable all options for this question
        for(let j=0; j<4; j++) {
          const b = document.getElementById("quiz_9817_q" + qi + "_o" + j);
          if(b) b.style.pointerEvents = "none";
        }
        // Show explanation
        const exp = document.getElementById("quiz_9817_q" + qi + "_explain");
        exp.style.display = "block";
        exp.style.background = isCorrect ? "rgba(34,197,94,.08)" : "rgba(248,113,113,.08)";
        exp.style.borderLeft = "3px solid " + (isCorrect ? "#22c55e" : "#f87171");
        exp.style.color = "#cbd5e1";
        exp.innerHTML = (isCorrect ? "‚úÖ Correct! " : "‚ùå Not quite. ") + explains[qi];
        // Update score
        const scoreEl = document.getElementById("quiz_9817_score");
        scoreEl.textContent = correct + "/4 correct";
        if (answered.size === 4) {
          scoreEl.style.color = correct === 4 ? "#22c55e" : correct >= 3 ? "#fbbf24" : "#f87171";
          scoreEl.style.fontWeight = "700";
        }
      };
    })();
  </script>

<!-- ‚ïê‚ïê‚ïê BEGINNER REFERENCE SECTIONS ‚ïê‚ïê‚ïê -->
  <div style="max-width:880px;margin:0 auto;padding:0 24px 32px">
    <!-- üìã Quick Cheat Sheet -->
    <div style="background:transparent;border:1px solid rgba(255,255,255,0.06);border-radius:14px;overflow:hidden;margin-bottom:24px">
      <div style="padding:14px 18px;border-bottom:1px solid #1f2d45;font-weight:700;font-size:.95rem;color:var(--text)">üìã Quick Cheat Sheet ‚Äî Callbacks vs Async/Await</div>
      <div style="overflow-x:auto">
        <table style="width:100%;border-collapse:collapse;font-size:.83rem">
          <thead><tr><th style="padding:10px 14px;background:rgba(255,255,255,0.02);color:#94a3b8;font-weight:600;font-size:.75rem;text-transform:uppercase;letter-spacing:.4px;border-bottom:1px solid #1f2d45;text-align:left">Code</th><th style="padding:10px 14px;background:rgba(255,255,255,0.02);color:#94a3b8;font-weight:600;font-size:.75rem;text-transform:uppercase;letter-spacing:.4px;border-bottom:1px solid #1f2d45;text-align:left">What it does</th><th style="padding:10px 14px;background:rgba(255,255,255,0.02);color:#94a3b8;font-weight:600;font-size:.75rem;text-transform:uppercase;letter-spacing:.4px;border-bottom:1px solid #1f2d45;text-align:left">When</th></tr></thead>
          <tbody>
            <tr><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:#7dd3fc;font-family:'Fira Code',monospace;font-size:.78rem"><code>callback(err, result)</code></td><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:var(--text)">Old pattern ‚Äî pass a function to call later</td><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:#94a3b8;font-size:.78rem">Node.js classic style</td></tr>
            <tr><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:#7dd3fc;font-family:'Fira Code',monospace;font-size:.78rem"><code>async function fn()</code></td><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:var(--text)">Declares a function that can use await</td><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:#94a3b8;font-size:.78rem">Modern JavaScript</td></tr>
            <tr><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:#7dd3fc;font-family:'Fira Code',monospace;font-size:.78rem"><code>await somePromise</code></td><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:var(--text)">Pauses until the Promise resolves</td><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:#94a3b8;font-size:.78rem">Only inside async functions</td></tr>
            <tr><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:#7dd3fc;font-family:'Fira Code',monospace;font-size:.78rem"><code>try { } catch (e) { }</code></td><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:var(--text)">Catches errors from await</td><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:#94a3b8;font-size:.78rem">Replaces error-first callbacks</td></tr>
            <tr><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:#7dd3fc;font-family:'Fira Code',monospace;font-size:.78rem"><code>.then().catch()</code></td><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:var(--text)">Promise chain ‚Äî older async style</td><td style="padding:10px 14px;border-bottom:1px solid #1f2d45;color:#94a3b8;font-size:.78rem">Still works, but await is cleaner</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- üí° Key Takeaways -->
    <div style="background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,0.06);border-radius:14px;padding:18px 20px;margin-bottom:24px">
      <div style="font-weight:700;font-size:.95rem;color:var(--text);margin-bottom:12px">üí° Key Takeaways for Beginners</div>
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:10px;font-size:.86rem;color:#cbd5e1;line-height:1.65"><span style="color:var(--text);flex-shrink:0">‚ñ∏</span><span>Callbacks = giving someone your <strong>phone number</strong> and saying "call me when it's ready." Works, but chains get messy.</span></div>
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:10px;font-size:.86rem;color:#cbd5e1;line-height:1.65"><span style="color:var(--text);flex-shrink:0">‚ñ∏</span><span>Async/Await = <strong>waiting in line</strong> at a counter. You pause, get your result, and continue. Clean and linear.</span></div>
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:10px;font-size:.86rem;color:#cbd5e1;line-height:1.65"><span style="color:var(--text);flex-shrink:0">‚ñ∏</span><span>"Callback Hell" happens when you nest callbacks inside callbacks ‚Äî code moves <strong>further and further right</strong> ‚û°Ô∏è‚û°Ô∏è‚û°Ô∏è.</span></div>
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:10px;font-size:.86rem;color:#cbd5e1;line-height:1.65"><span style="color:var(--text);flex-shrink:0">‚ñ∏</span><span>With <code>await</code>, error handling is just <code>try/catch</code> ‚Äî the same pattern you use for everything else.</span></div>
      <div style="display:flex;gap:10px;align-items:flex-start;margin-bottom:10px;font-size:.86rem;color:#cbd5e1;line-height:1.65"><span style="color:var(--text);flex-shrink:0">‚ñ∏</span><span><strong>Rule of thumb:</strong> Always use <code>async/await</code> in new code. Only use callbacks when a library forces you to.</span></div>
    </div>

    <!-- üíª Production Pattern -->
    <div style="background:transparent;border:1px solid rgba(255,255,255,0.06);border-radius:14px;overflow:hidden;margin-bottom:24px">
      <div style="padding:14px 18px;border-bottom:1px solid #1f2d45;font-weight:700;font-size:.95rem;color:var(--text)">üíª Async/await ‚Äî the modern way</div>
      <pre style="margin:0;padding:16px 18px;font-family:'Fira Code',monospace;font-size:.78rem;color:#94a3b8;overflow-x:auto;line-height:1.8;background:rgba(0,0,0,0.15)"><code>// ‚ùå OLD WAY ‚Äî Callback (nested and messy)
getData(userId, (err, user) => {
  if (err) { console.error(err); return; }
  getOrders(user.id, (err, orders) => {
    if (err) { console.error(err); return; }
    // Imagine 5 more levels deep... üò∞
  });
});

// ‚úÖ MODERN WAY ‚Äî Async/Await (flat and clean)
async function loadUserData(userId) {
  try {
    const user = await getData(userId);    // Step 1: get user
    const orders = await getOrders(user.id); // Step 2: get orders
    const details = await getDetails(orders); // Step 3: get details
    return details;  // Done! No nesting needed.
  } catch (err) {
    console.error('Something failed:', err); // One catch for all
  }
}</code></pre>
    </div>
  </div>

<div style="display:flex;gap:10px;justify-content:center;padding:24px;border-top:1px solid #1f2d45;flex-wrap:wrap">
    <a href="index.html"
      style="padding:9px 18px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);font-family:Inter,sans-serif;font-size:.83rem;font-weight:600;background:rgba(255,255,255,0.02);color:#94a3b8;text-decoration:none">&#127968;
      Home</a>
    <a href="learn2.html"
      style="padding:9px 18px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);font-family:Inter,sans-serif;font-size:.83rem;font-weight:600;background:transparent;color:#94a3b8;text-decoration:none">&#8592;
      Lesson 2</a>
    <a href="WEBSOCKET_STUDY_NOTES.md"
      style="padding:9px 18px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);font-family:Inter,sans-serif;font-size:.83rem;font-weight:600;background:transparent;color:#94a3b8;text-decoration:none">&#128218;
      Notes</a>
    <a href="learn4.html"
      style="padding:9px 18px;border-radius:8px;font-family:Inter,sans-serif;font-size:.83rem;font-weight:600;background:#fbbf24;color:#0a0d16;text-decoration:none;border:none">Lesson
      4: Chat App &#8594;</a>
  </div>
</body>

</html>